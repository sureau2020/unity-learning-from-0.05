# 开发阅读 9

呃呃以后可能还是得先阅读再开发，不然好像开着开着一天就过去了

## unity shader 入门精要

- unity2017 之后，UnityObjectToViewPos(_)函数来代替 mul(UNITY_MATRIX_MV, _)对顶点进行变换。

### 5.4

- semantics 语义可以让 Shader 知道从哪里读取数据，并把数据输出到哪里
- 一般存储了啥 shader 流水线不关心，而 Unity 为了方便对模型数据的传输，对一些语义进行了特别的含义规定
- 即便语义的名称一样，如果出现的位置不同，含义也不同
- DirectX 10 后，系统数值语义（system-value semantics）​。这类语义是以 SV 开头，有特殊的含义
- 个别平台只能用 SV_POSITION 而不能 POSITION，对于这些有特殊含义的变量我们最好使用以 SV 开头的语义进行修饰
- 对于这些有特殊含义的变量我们最好使用以 SV 开头的语义进行修饰
- TEXCOORDn 纹理坐标组，根据情况 max 有 8、16 组，从 0 开始
- 表 5.5，5.6，5.7Unity 支持的常用语义
- 通常，如果我们需要把一些自定义的数据从顶点着色器传递给片元着色器，一般选用 TEXCOORD0 等。
- 一个语义可以使用的寄存器只能处理 4 个浮点值（float）​。

### 5.5debug

#### 5.5.1 假彩色图像（false-color image）

- 把需要调试的变量映射到[0, 1]之间，作为颜色输出到屏幕上，然后通过屏幕上显示的像素颜色来判断这个值是否正确
- 由于颜色的分量范围在[0, 1]​
- 大于 1 的数值将会被设置为 1，小于 0 的数值会被设置为 0。因此，我们可以尝试使用不同的映射，直到发现颜色发生了变化 ​

#### 5.5.2 VS Graphics Debugger

- https://devblogs.microsoft.com/pix/documentation/
- https://learn.microsoft.com/en-us/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2022

#### 5.5.3 帧调试器（Frame Debugger

- Window -> Frame Debugger
- 这种方法虽然简单，但得到的信息也很有限。如果读者想要获取更多的信息，还是需要使用外部工具，例如 5.5.2 节中的 Visual Studio 插件，或者 Intel GPA、RenderDoc、NVIDIA NSight、AMD GPU PerfStudio 等工具。

### 5.6 渲染平台的差异

- OpenGL 坐标系类数学，DirectX 坐标系类 Dr.Racket
- unity，在 DirectX 平台上使用渲染到纹理技术时，会为我们翻转屏幕图像纹理
- 开启了抗锯齿（在 Edit -> Project Settings -> Quality -> Anti Aliasing 中开启）并在此时使用了渲染到纹理技术，就不会自动翻转
- 如果我们需要同时处理多张渲染图像在 DirectX 上（前提是开启了抗锯齿）​，要自己在顶点着色器中翻转某些渲染纹理（例如深度纹理或其他由脚本传递过来的纹理）的纵坐标，使之都符合 DirectX 平台的规则。

```
        #if  UNITY_UV_STARTS_AT_TOP
        if  (_MainTex_TexelSize.y  <  0)
              uv.y  =  1-uv.y;
        #endif
```

- UNITY_UV_STARTS_AT_TOP 用于判断当前平台是否是 DirectX 类型的平台，而当在这样的平台下开启了抗锯齿后，主纹理的纹素大小在竖直方向上会变成负值，以方便我们对主纹理进行正确的采样
- http://docs.unity3d.com/Manual/SL-PlatformDifferences.html

### 5.7 Shader 整洁之道

- 尽可能使用精度较低的类型
- 尽可能减少 Shader 中的运算，或者通过预计算的方式来提供更多的数据
- 慎用分支和循环语句 大体来说，GPU 使用了不同于 CPU 的技术来实现分支语句，在最坏的情况下，我们花在一个分支语句的时间相当于运行了所有分支语句的时间
- 尽量把计算向流水线上端移动，例如把放在片元着色器中的计算放到顶点着色器中，或者直接在 CPU 中进行预计算，再把结果传递给 Shader
- ·分支判断语句中使用的条件变量最好是常数，即在 Shader 运行过程中不会发生变化；·每个分支中包含的操作指令数尽可能少；·分支的嵌套层数尽可能少。
- 对那些除数可能为 0 的情况，强制截取到非 0 范围

## unity learn creative core

### lighting

Window > Rendering > Light

#### The Baked Global Illumination system 烘焙全局照明系统

- Lightmapping 光照贴图： 预先计算场景中表面的亮度，并将结果存储在纹理（称为光照贴图） 中的过程,使用 Progressive Lightmapper
- Progressive Lightmapper 渐进式 GPU 光照贴图器是渐进式光照贴图器的后端，它使用计算机的 GPU 和专用视频内存 (VRAM) 来生成烘焙光照贴图
  和光探测器
- Light Probes 光探测器： 一种用于测量（或探测）穿过场景中空白空间的光的数据的工具。
- Reflection Probes 反射探针： 在 Unity 中模拟更真实反射的工具
- 所有渲染管道都支持烘焙全局照明系统
- 烘焙光照效率高，但比较死，结果可能不符合预期，得变

#### The Realtime Global Illumination system 实时全局照明系统

- 旧系统，已经弃用，之前用在 built-in 里
- 该全局照明系统使用一种称为“Enlighten Lightmapper”的已弃用的光照贴图器

### skybox

- Textured 一组使用材质纹理生成天空盒的着色器。
- Procedural 使用材质上的属性来生成天空盒的着色器。
- 新建材质，shader 改成 skybox 里的 procedural，弄完拖给 lighting 里的 environment
- Exposure 曝光： 调整天空的曝光度。数值越大，天空盒的曝光度越高，看起来也越亮。
- Atmosphere Thickness 越厚越吸收定向光的颜色

### 别的

- Intensity 200-600
- Indirect Multiplier 间接乘数 (Indirect Multiplier) 属性会影响此光源提供的间接光,值大于 1 时 ，间接光每次反射都会变得更亮。这不太自然，但如果你想照亮场景中黑暗、封闭的空间，这种方法会非常有用。
- 游戏对象需要标记为 “静态” 才能包含在光照贴图中，用于环境光照明。这是因为光照贴图数据是预先计算的，并且只能针对运行时不移动的游戏对象进行计算。在为该场景烘焙光照时，您将了解更多信息。要在实验过程中查看变化，请按下 “光照”选项卡底部的 “生成光照” 。
- environment 的 source 改成 gradient 可调颜色
- 阴影存储在一种名为阴影贴图 (shadow map) 的纹理中。阴影贴图将场景中的所有内容平铺成一张纹理（图像），然后将阴影打印到纹理上。纹理分辨率越高，场景中阴影的质量就越高。
- 默认用 URP-HighFidelity
- The Depth Bias and Normal Bias properties help address issues where pixels on an object are in shadow but should actually be lit
- Cascades Count 它控制项目中使用的阴影级联数量 。这有助于解决由定向光（透视混叠）造成的靠近摄像机的阴影像素化问题。场景中使用的级联越多，阴影受透视混叠的影响就越小。
