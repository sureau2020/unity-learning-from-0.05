# 阅读开发 2

我要试试是先开发容易还是先阅读容易。今天先阅读

### 4.6 杂记

- Mc→p 是一个正交矩阵的话 Mp→c 是其转置
- 如果我们知道坐标空间变换矩阵 MA→B 是一个正交矩阵，那么我们可以提取它的第一列来得到坐标空间 A 的 x 轴在坐标空间 B 下的表示，还可以提取它的第一行来得到坐标空间 B 的 x 轴在坐标空间 A 下的表示
- 如果我们知道坐标空间 B 的 x 轴、y 轴和 z 轴（必须是单位矢量，否则构建出来的就不是正交矩阵了）在坐标空间 A 下的表示，就可以把它们依次放在矩阵的每一行就可以得到从 A 到 B 的变换矩阵了。
- 模型空间（model space）​aka 对象空间（object space）或局部空间（local space）​。每个模型都有自己独立的坐标空间，当它移动或旋转的时候，模型空间也会跟着它移动和旋转。
- Unity 中+x 轴、+y 轴、+z 轴分别对应的是模型的右、上和前向
- 一个三维坐标扩展到齐次坐标时，通常就是在末尾加一个 1，从而变成四维向量。点的 w 分量是 1，方向矢量的 w 分量是 0
- 世界空间可以被用于描述绝对位置。通常，我们会把世界空间的原点放置在游戏空间的中心。x 轴、y 轴、z 轴是固定不变
- 顶点变换的第一步，就是将顶点坐标从模型空间变换到世界空间中。这个变换通常叫做模型变换（model transform）​。
- Pworld = Mmodel\*Pmodel
- Mmodel = 平移*旋转*缩放（从右读
- 观察空间（view space）也被称为摄像机空间（camera space）​ 使用右手坐标系（符合 OpenGL 传统）
- 顶点变换的第二步，就是将顶点坐标从世界空间变换到观察空间中。这个变换通常叫做观察变换（view transform）​。需要知道世界坐标系下摄像机的变换信息
- 观察空间（camera space）在渲染阶段会按照 OpenGL 的右手系约定来处理变换。Camera.worldToCameraMatrix 会自动翻转，但如果自己构建的话要记得翻转 z 轴
- 世界坐标至观察坐标：方法一 —— 从“观察空间 → 世界空间”的变换出发，再取逆，得到世界 → 观察空间。方法二，不动摄像机，而是移动世界空间中的所有物体。世界空间中的物体必须经过一个逆向的摄像机变换，即：首先“把世界平移”来让摄像机位置回到原点，然后“把世界旋转”，让世界坐标轴对准摄像机坐标轴（直接从构造矩阵时逆向思考（乘之前挨个逆向））//先乘再逆先逆再乘
- 顶点接下来要从观察空间转换到裁剪空间（clip space，也被称为齐次裁剪空间）中，这个用于变换的矩阵叫做裁剪矩阵（clip matrix）​，也被称为投影矩阵（projection matrix）​。视锥体（view frustum）来决定保留空间
- 视锥体指的是空间中的一块区域，这块区域决定了摄像机可以看到的空间。视锥体由六个平面包围而成，这些平面也被称为裁剪平面（clip planes）​。视锥体有两种类型，这涉及两种投影类型：一种是正交投影（orthographic projection）​，一种是透视投影（perspective projection）​。
- 近剪裁平面（near clip plane）和远剪裁平面（far clip plane）​。它们决定了摄像机可以看到的深度范围
- 透视投影的视锥体是一个金字塔，正交投影的视锥体是一个长方体
- 通过一个投影矩阵把顶点转换到一个裁剪空间中，并没有进行真正的投影工作，而是在为投影做准备。真正的投影发生在后面的齐次除法（homogeneous division）过程中。而经过投影矩阵的变换后，顶点的 w 分量将会具有特殊的意义。
- 投影矩阵也是对 x、y、z 分量进行缩放。我们上面讲过直接使用视锥体的 6 个裁剪平面来进行裁剪会比较麻烦。而经过投影矩阵的缩放后，我们可以直接使用 w 分量作为一个范围值，如果 x、y、z 分量都位于这个范围内，就说明该顶点位于裁剪空间内。

#### 透视投影

- 图 4.38 透视摄像机的参数对透视投影视锥体的影响
- 有几个公式目前不需要记
- 如果一个顶点在视锥体内，那么它变换后的坐标必须满足-w<=x,y,z<=w
- 裁剪矩阵会改变空间的旋向性：空间从右手坐标系变换到了左手坐标系。这意味着，离摄像机越远，z 值将越大。

#### 正交投影

- 正交投影的视锥体是一个长方体，因此计算上相比透视投影来说更加简单(看图 4.40)
- nearClipPlaneHeight=2·Size；farClipPlaneHeight=nearClipPlaneHeight
- nearClipPlaneWidth=Aspect·nearClipPlaneHeight
- 和透视投影不同的是，使用正交投影的投影矩阵对顶点进行变换后，其 w 分量仍然为 1
- 裁剪矩阵改变了空间的旋向性
- 经过正交投影变换后的顶点实际已经位于一个立方体内了

---

- 经过投影矩阵的变换后，我们可以进行裁剪操作。当完成了所有的裁剪工作后，就需要进行真正的投影了，也就是说，我们需要把视锥体投影到屏幕空间（screen space）中。经过这一步变换，我们会得到真正的像素位置，而不是虚拟的三维坐标
- 首先，我们需要进行标准齐次除法（homogeneous division）​，也被称为透视除法（perspective division）​。用齐次坐标系的 x、y、z 分量除以 w
- 把四维齐次坐标[x,y,z,w]转换成三维标准坐标时，w 分量本质是透视投影的缩放因子。当物体远离相机时 w 增大，除法操作让坐标值缩小，自然产生“近大远小”的透视效果
- OPENGL 中，这一步得到的坐标叫做归一化的设备坐标（Normalized Device Coordinates, NDC）​。
- 透视投影的裁剪空间会变换到一个立方体，正交投影不变（本来 w 就都是 1）
- 现在，我们可以根据变换后的 x 和 y 坐标来映射输出窗口的对应像素坐标。在 Unity 中，屏幕空间左下角的像素坐标是（0, 0）​，右上角的像素坐标是(pixelWidth, pixelHeight)。由于当前 x 和 y 坐标都是[-1, 1]​，因此这个映射的过程就是一个缩放的过程。
- 通常，z 分量会被用于深度缓冲。有可能直接存也可能根据驱动生产商会根据硬件来选择最好的存储格式
- clipw 也并不会被抛弃，会在后续的一些工作中起到重要的作用，例如进行透视校正插值。
- 在 Unity 中，从裁剪空间到屏幕空间的转换是由 Unity 帮我们完成的。我们的顶点着色器只需要把顶点转换到裁剪空间即可。
- 图 4.45 渲染流水线中顶点的空间变换过
- 顶点着色器的最基本的任务就是把顶点坐标从模型空间转换到裁剪空间中。这对应了图 4.45 中的前三个顶点变换过程。而在片元着色器中，我们通常也可以得到该片元在屏幕空间的像素位置。
- 只有在观察空间中 Unity 使用了右手坐标系

### 4.7 法线变换 杂记

- 法线（normal）​，也被称为法矢量（normal vector）​。顶点携带法线信息
- 需要变换顶点法线，以便在后续处理（如片元着色器）中计算光照等
- 在变换法线的时候，如果使用同一个变换矩阵，可能就无法确保维持法线的垂直性
- 顶点也携带切线信息，切线和法线互相垂直
- 切线是由两个顶点之间的差值计算得到的，因此我们可以直接使用用于变换顶点的变换矩阵来变换切线。
- 非统一缩放时，如果使用和变换顶点相同的变换矩阵来变换法线，就会得到错误的结果，即变换后的法线方向与平面不再垂直
- 通过切法垂直，使用原变换矩阵的逆转置矩阵来变换法线就可以得到正确的结果
- 如果变换矩阵 MA→B 是正交矩阵，直接变换法线
- 如果变换只包括旋转变换，那么这个变换矩阵就是正交矩阵，如果只包含旋转和统一缩放系数 k，用（1/k）\*MA→B
- 如果变换中包含了非统一变换，必须解逆矩阵来得到变换法线的矩阵

### 4.8 Unity Shader 的内置变量（数学篇）

- 内置变量可以在 UnityShaderVariables.cginc 文件中找到定义和说明。
- 4.8 当字典查
  4.9 写码了遇到问题再回来看

---

明天如果看的话从第五章开始。  
今天下午出去了晚上做饭了所以没写码。明天要写学校作业，尽量早上仨小时写完吧，下午先从码开始，试试先写码再学习会不会好些。但早上也不看手机试试
